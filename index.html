<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Brick Breaker - Three.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
    let scene, camera, renderer, particles, paddle, ball;
    let ballVelocity = new THREE.Vector3(2, -2, 0);
    let paddleSpeed = 0;
    const paddleBoundary = 250;
    const imageURL = "https://i.imgur.com/dEETdyO.jpeg";
    let particleGeometry;
    let imageHeight = 250;
    let gameStarted = false;
    const paddleOffset = 500;
    let lives = 3;

    init();

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 800;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        loadImage(imageURL);
        createPaddle();
        createBall();
        animate();

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
    }

    function loadImage(url) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        img.onload = function () {
            processImage(img);
        };
    }

    function processImage(img) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0, img.width, img.height);

        const imageData = ctx.getImageData(0, 0, img.width, img.height).data;
        createParticles(imageData, img.width, img.height);
    }

    function createParticles(imageData, width, height) {
        particleGeometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        const verticalOffset = 400;

        for (let y = 0; y < height; y += 5) {
            for (let x = 0; x < width; x += 5) {
                const index = (y * width + x) * 4;
                const r = imageData[index] / 255;
                const g = imageData[index + 1] / 255;
                const b = imageData[index + 2] / 255;
                const a = imageData[index + 3] / 255;

                if (a > 0.2) {
                    positions.push(
                        x - width / 2,
                        (-y + height / 2) + verticalOffset,
                        0
                    );
                    colors.push(r, g, b);
                }
            }
        }

        particleGeometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
        particleGeometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ vertexColors: true, size: 4 });

        particles = new THREE.Points(particleGeometry, material);
        scene.add(particles);
    }

    function createPaddle() {
        const geometry = new THREE.BoxGeometry(120, 10, 10);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        paddle = new THREE.Mesh(geometry, material);

        paddle.position.y = -paddleOffset;
        scene.add(paddle);
    }

    function createBall() {
        const geometry = new THREE.SphereGeometry(10, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        ball = new THREE.Mesh(geometry, material);
        ball.position.set(0, -paddleOffset + 20, 0);
        scene.add(ball);
    }

    function onKeyDown(event) {
        if (event.key === "ArrowLeft") {
            paddleSpeed = -7;
        }
        if (event.key === "ArrowRight") {
            paddleSpeed = 7;
        }
        if (event.key === " " && !gameStarted) {
            gameStarted = true;
        }
    }

    function onKeyUp(event) {
        if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
            paddleSpeed = 0;
        }
    }

    function resetGame() {
        gameStarted = false;
        ball.position.set(0, -paddleOffset + 20, 0);
        paddle.position.set(0, -paddleOffset, 0);
        ballVelocity.set(2, -2, 0);
    }

    function resetEntireGame() {
        lives = 3;
        resetGame();
        if (particles) {
            scene.remove(particles);
        }
        loadImage(imageURL);
    }

    function animate() {
        requestAnimationFrame(animate);

        paddle.position.x += paddleSpeed;
        paddle.position.x = Math.max(-paddleBoundary, Math.min(paddleBoundary, paddle.position.x));

        if (!gameStarted) {
            ball.position.x = paddle.position.x;
            ball.position.y = paddle.position.y + 20;
        } else {
            ball.position.add(ballVelocity);
        }

        if (ball.position.x > 250 || ball.position.x < -250) {
            ballVelocity.x *= -1;
        }
        if (ball.position.y > 250) {
            ballVelocity.y *= -1;
        }
        if (ball.position.y <= paddle.position.y + 15 && 
            ball.position.y >= paddle.position.y - 15 &&
            ball.position.x >= paddle.position.x - 70 &&
            ball.position.x <= paddle.position.x + 70) {
            ball.position.y = paddle.position.y + 15;
            ballVelocity.y *= -1;
            const hitPoint = (ball.position.x - paddle.position.x) / 70;
            ballVelocity.x = hitPoint * 3;
        }
        if (ball.position.y < -paddleOffset - 100) {
            lives--;
            if (lives <= 0) {
                alert("Game Over! Starting new game...");
                resetEntireGame();
            } else {
                alert(`${lives} lives remaining! Continue playing...`);
                resetGame();
            }
        }

        if (particles && particleGeometry) {
            const positions = particleGeometry.attributes.position.array;
            const positionsToRemove = [];

            for (let i = 0; i < positions.length; i += 3) {
                const dx = ball.position.x - positions[i];
                const dy = ball.position.y - positions[i + 1];

                if (dx * dx + dy * dy < 400) {
                    positionsToRemove.push(i);
                    ballVelocity.y *= -1;
                }
            }

            if (positionsToRemove.length > 0) {
                removeParticles(positionsToRemove);
                if (particleGeometry.attributes.position.array.length === 0) {
                    alert("ðŸŽ‰ Congratulations! You won!");
                    location.reload();
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;
        }

        renderer.render(scene, camera);
    }

    function removeParticles(indices) {
        const positions = particleGeometry.attributes.position.array;
        const colors = particleGeometry.attributes.color.array;
        const newPositions = [];
        const newColors = [];

        for (let i = 0; i < positions.length; i += 3) {
            if (!indices.includes(i)) {
                newPositions.push(positions[i], positions[i + 1], positions[i + 2]);
                newColors.push(colors[i], colors[i + 1], colors[i + 2]);
            }
        }

        particleGeometry.setAttribute("position", new THREE.Float32BufferAttribute(newPositions, 3));
        particleGeometry.setAttribute("color", new THREE.Float32BufferAttribute(newColors, 3));
    }

    window.addEventListener("resize", function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>
